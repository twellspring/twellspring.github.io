---
layout: post
title: Saltstack and a well formed hostname simplifies your top
---

When I first started out using SaltStack, I setup a role based configuration where each server has one or more roles and those roles contain everything required to setup the server.  There is the **common** role which as you might expect from its name is applied to all server.  Then there will be at least one functional role.  My two most common are php and node.

A problem that quickly surfaced was how to connect a server to the pillars and states it needed.   Using the **top file** is the obvious answer. At its simplest the top file matches by minion ID, which in most instances is the hostname. So assuming my server names include php and node, the following top file works to configure the servers and can be used for both the pillar and the state top file.

top.sls
```
base:
    '*':
        - roles/common
    '*-php-*':
        - roles/php
    '*-node-*':
        - roles/node
```

But as I add more roles the top file gets more and more complex.   Right now I have 17 different roles.   So that is 17 different stanzas in the top file for my base environment.  And if I add in multiple environments ( test, stage, prod ) and servers with different functions that use the same node role, the top file is going to get really big and ugly.

Using custom grains to identify role is proposed by some people, but that adds to the top file ugliness and has security implications.  On a compromised server the custom grains in /etc/salt/grains could be changed resulting in additional pillar data being exposed to the compromiser.  So to me that puts using custom grains on the **no way** list.

One piece of data from the minion that can not be altered is the ID, since that is part of the key that is accepted when salt minion is first installed.   Changing the ID means the key no longer matches and the minion can no longer connect to the master.  And since the ID is the hostname, we can use the hostname as a safe method for making decisions about a server.

Enter the well formed hostname.  Some people enjoy **creative** naming schemes: movie names, Game of Thrones characters, Greek gods.   Thats fine if they want to use them, but for me a well formed name gives much more of practical benefit.  I think at a minimum the well formed name needs:
* datacenter - I assume every organization has or will have more than one
* environment - test, staging, prod
* function - what the server is used for
* number - a way to distinguish multiple servers with similar functions apart

So the naming scheme for this example will be  datacenter-function-environment-number ( example: west-api-prod-1 ).  In this scheme the second item is the really important piece as it tells us the function of the server.  I call that the nameslug. Lets put this nameslug to use to simplify the pillar top file.

pillar/top.sls
```
base:
    '*-*-*-*':
        - roles/common
        - nameslug
```

pillar/nameslug.sls
```
{%- set name_parts = {} %}
{%- set namesplit   = grains['id'].split('-') %}
{%- set nameslug = namesplit[1] }

include:
  - nameslug/{{ nameslug }}
```

The top file includes nameslug.  nameslug.sls extracts the nameslug out of the ID and then includes a file in the nameslug directory.   Nameslug directory ... guess we need to create that.   Each server type will have a corresponding "file" in the nameslug directory.   While I could use actual sls files here, I found that using symbolic links in the nameslug directory allowed it to be a more flexible mapping rather than holding content.  Where does it map to?  that depends on the server function.   Here is a simple pillar hierarchy

```
pillar
  nameslug
  roles
    php
    node
    vpn
```

For a VPN server we would create a nameslug that maps to the vpn role.
```
cd nameslug
ln -s ../roles/vpn vpn
```

For the VPN server we have accomplished our goal:  to use the server name to map to a role.  But if we have a web server ( www ) and an api server ( api ) that both use PHP, this mapping does not work.   Lets add a new directory for apps to help us resolve this.

```
pillar
  apps
    api
    www
  nameslug
  roles
    php
    node
    vpn
```

Now we create nameslugs to map the api and www slugs to the corresponding apps;

```
cd nameslug
ln -s ../apps/api.sls api.sls
ln -s ../apps/www.sls www.sls
```

And the sls files in the apps hierarchy are used to add roles to these servers.  Here is the api file.

pillar/apps/api.sls
```
include:
  - roles/php

application:
  name: api
  git: git@github.com:mycompany/api.git
  ...
```

The api server now has both been mapped to the php role and has the application specific data needed to install the correct application.  All of the above only gets us the correct pillar.  We need to also get the correct states on this server, and we use the roles pillar to do this.

pillar/roles/php.sls
```
php:
  version: 5.5
  user: www-data
  deploy_dir: /home/www-data/php

roles:
  php: true
```

pillar/roles/common.sls
```
common:
  packages:
    - git
    - nmap
    - top
    - zip

roles:
  common: true
```

Each rolls pillar contains both role specific data and then the general roles pillar.  Due to how the include logic of Saltstack works, if a server has multiple roles these roles are appended to the roles pillar.  Now in the top.sls I create a loop to on the roles pillar to include the state roles:

state/top.sls
```
'*-*-*-*-*':
  {%- for role, args in salt['pillar.get']('roles', {}).items() %}
      - roles/{{ role }}
  {%- endfor %}
```

Based on the above a server named west-api-prod-1 would include the state roles common and api.

To summarize how this works:
* The pillar top file includes nameslug
* nameslug.sls extracts the nameslug out of the server name and includes the corresponding nameslug/xxxx
* nameslug/xxxx.sls is a symbolic link to either a role or an application sls file.
* If it maps to an application, that application includes a role and creates an app specific pillar
* role files include a role specific pillar and an entry in the roles pillar
* state top file includes all roles from the roles pillar via a jinja loop

This structure has worked well for me.  I started out with 2 roles and 3 apps and now with 17 roles and 35 apps it still works.  Instead of a long complex top file, I have a well organized hierarchy with lots of small easy to understand files with well defined content.  Hopefully this can work for you too, or at least give you ideas for a structure that will work for you.

So what about the other parts of the **well formed hostname**? Those parts are useful and will be well used, but that is for another post.
