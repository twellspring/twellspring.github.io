<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Todd Wells</title>
    <description>Techie type with his feet in the Sierra Nevada Mountains and his head in the cloud</description>
    <link>http://twellspring.github.io/</link>
    <atom:link href="http://twellspring.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 19 Apr 2016 22:06:52 -0700</pubDate>
    <lastBuildDate>Tue, 19 Apr 2016 22:06:52 -0700</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      
      <item>
        <title>Hubot and Slack Security concerns</title>
        <description>&lt;p&gt;The last post used middleware to restrict what room commands can run it.  But there is still no restrictions on who can use a command and what server they can run it on.   It does not take my 10 years of work at financial companies and countless audits to know that this level of open access is not a good idea.   So before Hubot gets implemented I want to have a minimal level of security.   Remember I am going for MVP here, not what I think will be the end all security design a year from now.   Walk before running.&lt;/p&gt;

&lt;p&gt;The minimum I see is:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Admins can run commands like deploy on any server&lt;/li&gt;
  &lt;li&gt;Non-admins can run commands like deploy only on testing servers&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Fortunately all my servers have well defined names and the environment of a server can be easily parsed out of the name&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server_split = server_name.split &quot;-&quot;
server_env = server_split[3]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now I just need put a check at the top of the deploy command that will check the above server_env.   I created a global function to validate the above two conditions are met:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = (robot) -&amp;gt;

  class myCompany

    restrictServer: (msg,server) -&amp;gt;
      user = msg.envelope.user
      server_split = server_name.split &quot;-&quot;
      server_env = server_split[3]
      return false if server_env == &#39;test&#39;
      return false if robot.auth.isAdmin(user)

      msg.send &quot;You are not authorized to run this command on #{server}&quot;
      return true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The two lines starting with &lt;strong&gt;return false&lt;/strong&gt; are my conditions.   If either of these conditions are met the function returns false, which means the command should not be restricted.   If both are not true it sends a message and returns true.  The first checks if the server is a test server.  If so, anyone can deploy to it.   The second checks if the user is an Admin, which is defined in the environment when starting up Hubot.&lt;/p&gt;

&lt;p&gt;Now at the top of my deploy command ( and any other command that needs this security)  I put in a check&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;robot.respond /deploy ([\w-]+) to ([\w-]+) version ([\w-_/\.]+)?([\w-_]+)?/i, (msg) -&amp;gt;
  appName     = msg.match[1]
  serverName  = msg.match[2]
  appVersion = msg.match[3]

  return if robot.myCompany.restrictServer(msg, serverName )
  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;To test this I used local Hubot.  Adding &lt;code class=&quot;highlighter-rouge&quot;&gt;HUBOT_AUTH_ADMIN=1&lt;/code&gt; to the environment means the Shell user is an admin and &lt;code class=&quot;highlighter-rouge&quot;&gt;HUBOT_AUTH_ADMIN=2&lt;/code&gt; ( or any other value ) means Shell is not.  This allowed me to validate the above restrictions worked as I expected. Then when I deploy this to my production server and run it with Slack I will add my Slack ID to the &lt;code class=&quot;highlighter-rouge&quot;&gt;HUBOT_AUTH_ADMIN&lt;/code&gt; variable.&lt;/p&gt;

&lt;p&gt;Just to clarify, restrictServer being true will cause the &lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt; line above to exit the robot.respond function and not process the rest of the command.   This is what we want.  Only if restrictServer returns false ( do not restrict server ) do we want to continue.   And the only way restrictServer returns false if one of the two conditions I set forth at the beginning of this article is met.&lt;/p&gt;

&lt;p&gt;After testing this thoroughly locally I was ready to deploy Hubot to Slack ( without telling anyone ) so that I could test it there.  Then when I was confident that users could only affect test servers I told the developers about Hubot and let the flood of &lt;strong&gt;pug me&lt;/strong&gt; command commence.&lt;/p&gt;

&lt;p&gt;MVP done and ChatOps 1.0.0 released to my company with much excitement, and a week or two later developers start to really use it.   Life is pretty good.   But of course being a devops/sysadmin/linux/unix guy I am not satisfied with this and want to improve upon it.  And that 10 years of Financial screams at me for the first improvement to be in security.   Sigh, I guess I can’t ignore that voice.   So better security is up next, and I think we need some kind of role based authentication/authorization.   Slack takes care of the authentication and we can use the hubot-auth model for the roles and authorization.&lt;/p&gt;
</description>
        
          <description>&lt;p&gt;The last post used middleware to restrict what room commands can run it.  But there is still no restrictions on who can use a command and what server they can run it on.   It does not take my 10 years of work at financial companies and countless audits to know that this level of open access is not a good idea.   So before Hubot gets implemented I want to have a minimal level of security.   Remember I am going for MVP here, not what I think will be the end all security design a year from now.   Walk before running.&lt;/p&gt;

</description>
        
        <pubDate>Tue, 19 Apr 2016 00:00:00 -0700</pubDate>
        <link>http://twellspring.github.io/blog/hubot-slack-security-concerns/</link>
        <guid isPermaLink="true">http://twellspring.github.io/blog/hubot-slack-security-concerns/</guid>
        
        
      </item>
      
    
      
      <item>
        <title>Using Hubot Middleware to Restrict Rooms</title>
        <description>&lt;p&gt;Today’s post is a small diversion from the security topic I planned because something came up that I wanted to address first … where hubot could be accessed from.   Slack’s Hubot integration creates Hubot as a robot similar to slackbot, except that hubot has to be invited to a channel where slackbot is already listening in every channel.   Since Hubot is being used for ChatOps, I want to limit where server commands can be executed.  Limiting what channel hubot is in does not work as anyone can invite hubot to a new channel.    So the limits need to be within hubot.   This could be done on a per command basis, but that complexity and granularity is not needed at this time. So for now it will be a global limit on all hubot commands to certain channels.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/github/hubot/blob/master/docs/scripting.md#execution-process-and-api&quot;&gt;Hubot Middleware&lt;/a&gt; is the tool for this job.  The room limiting logic will be a white list.  Any command in a room not on the white list will be silently dropped.&lt;/p&gt;

&lt;p&gt;Time for a new file &lt;code class=&quot;highlighter-rouge&quot;&gt;middleware.coffee&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Description:
#   Middleware Commands
#
# Dependencies:
#
# Commands:
#
# Notes:
#

module.exports = (robot) -&amp;gt;

  robot.receiveMiddleware (context, next, done) -&amp;gt;
    room = context.response.message.room
    next() if room in [&#39;staging&#39;, &#39;testing&#39;  ]
    done()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The receiveMiddleware acts after the listener ( robot.respond, … ) matches but before the body of the listener function executes.  It gets the room from the context object and compares it to a list.  If there is a match the &lt;code class=&quot;highlighter-rouge&quot;&gt;next()&lt;/code&gt; sends the request on to be processed to normally.   If it does not match &lt;code class=&quot;highlighter-rouge&quot;&gt;done()&lt;/code&gt; silently stops this request and nothing more happens.&lt;/p&gt;

&lt;p&gt;A quick test in my local development environment shows a problem.   No commands now work.   Adding a logging line after the room value is set ( &lt;code class=&quot;highlighter-rouge&quot;&gt;console.log &quot;room = #{room}&quot;&lt;/code&gt; ) shows the issue.   When using locally, the room is &lt;strong&gt;Shell&lt;/strong&gt;, same as the user name.    I could put Shell in the list, but putting in the user name value rather than a fixed &lt;strong&gt;Shell&lt;/strong&gt; will also allow Slack DM to work as Slack Direct Messages also have a room name equal to the user name.    Here is the improved middleware.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # Limit responses to the listed rooms, Shell and Slack DM
  robot.receiveMiddleware (context, next, done) -&amp;gt;
    room = context.response.message.room
    user = context.response.message.user.name
    next() if room in [&#39;staging&#39;, &#39;testing&#39;, user ]
    done()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Done and done.  Now even if a user invites Hubot somewhere he should not be, Hubot will not respond.&lt;/p&gt;
</description>
        
          <description>&lt;p&gt;Today’s post is a small diversion from the security topic I planned because something came up that I wanted to address first … where hubot could be accessed from.   Slack’s Hubot integration creates Hubot as a robot similar to slackbot, except that hubot has to be invited to a channel where slackbot is already listening in every channel.   Since Hubot is being used for ChatOps, I want to limit where server commands can be executed.  Limiting what channel hubot is in does not work as anyone can invite hubot to a new channel.    So the limits need to be within hubot.   This could be done on a per command basis, but that complexity and granularity is not needed at this time. So for now it will be a global limit on all hubot commands to certain channels.&lt;/p&gt;

</description>
        
        <pubDate>Tue, 12 Apr 2016 00:00:00 -0700</pubDate>
        <link>http://twellspring.github.io/blog/using-hubot-middleware-to-restrict-rooms/</link>
        <guid isPermaLink="true">http://twellspring.github.io/blog/using-hubot-middleware-to-restrict-rooms/</guid>
        
        
      </item>
      
    
      
      <item>
        <title>Hubot Global Functions</title>
        <description>&lt;p&gt;Researching global functions in Hubot lead me down two interesting paths: Classes and Middleware.  Middleware is pretty well documented on the &lt;a href=&quot;https://github.com/github/hubot/blob/master/docs/scripting.md&quot;&gt;Hubot Scripting page&lt;/a&gt;.  Classes on the other hand not so much.   So for learning about those … you guessed it … go to the code.  And with that I see that while Middleware has other uses, the Class is what I will use to create what I am calling a &lt;strong&gt;global function&lt;/strong&gt; (in javascript terminology this is a class with a method).   In another .coffee file in the scripts directory, create a Class and then a method in that class for the CC script. I decided to create a class with my company name as the class.  I will add other global functions under this same class so they are all grouped under my company name.  This methodology is likely to change as I learn more, but its working for now.  Here is what it looks like.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = (robot) -&amp;gt;

  class myCompany

    cc: (msg, ccRoom, ccText) -&amp;gt;
      room = msg.envelope.room
      user = msg.envelope.user.name

      return if ccRoom == room
      return if user == &quot;Shell&quot;

      robot.messageRoom ccRoom &quot;#{ccText}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Notice I had to change the = after the local function name into a colin for method name.  Other than that the function could be moved as is.   Now to call it.   In my code replace the cc line with&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  robot.myCompany.cc(msg, ccRoom, &quot;Successfully deployed #{appName} to #{serverName}&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;That makes pretty quick work out of the first half.   Now what to do with that global variable.  As I thought about this I realized one global variable would not solve the problem.  Where a CC goes will depend on the input.   In my case I wanted to be able to cc a different room based on the environment of the server that a command is being run on ( test, stage, prod).   This will require 3 pieces&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;a method to get an environment out of a server name&lt;/li&gt;
  &lt;li&gt;a map of strings to room name&lt;/li&gt;
  &lt;li&gt;a call to the map to convert the server environment to the room name&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here are the three pieces in code.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server_split = server_name.split &quot;-&quot;
server_env = server_split[3]

slackRoomMap =
  test: process.env.HUBOT_SLACK_TEST_ROOM
  stage: process.env.HUBOT_SLACK_STAGING_ROOM
  prod: process.env.HUBOT_SLACK_PROD_ROOM

ccRoom = slackRoomMap[ccString] ? ccString

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Using the split method to get the environment works because my server names are well formed and the 4th section is always an environment.   Since the split function array starts at 0, server_split[3] is the fourth object in the array.  The slackRoom map is a basic CoffeeScript object literal. And replyRoom is set using the bracket notation to access the appropriate value in the object literal.  ? is an existential operator which returns the value after the ? if the value before does not exist or is null.  In English, this means if there is no match in the slackRoomMap to treat the passed ccSting as ccRoom.  So I can now pass either an enviroment name or a room name and the CC will go to the appropriate room in either case.&lt;/p&gt;

&lt;p&gt;My revised global function now looks like this.   Note the change in the ccRoom in the method definition to ccString.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = (robot) -&amp;gt;

  class myCompany

    cc: (msg, ccString, ccText) -&amp;gt;
      room = msg.envelope.room
      user = msg.envelope.user.name

      slackRoomMap =
        test: process.env.HUBOT_SLACK_TEST_ROOM
        stage: process.env.HUBOT_SLACK_STAGING_ROOM
        prod: process.env.HUBOT_SLACK_PROD_ROOM

      ccRoom = slackRoomMap[ccString] ? ccString

      return if ccRoom == room
      return if user == &quot;Shell&quot;

      robot.messageRoom ccRoom &quot;#{ccText}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;For where I am in my Hubot development this is sufficient as I don’t see any near future needs for more mappings.   Of course I would rather have a more elegant method for setting these rooms, maybe pass yaml/json in the ENV variable or some other good trick.  But I have to keep telling myself not to try to do to much.  If in the future I need a better method for mapping rooms I can deal with it then.&lt;/p&gt;

&lt;p&gt;Next up is the ( hopefully ) last piece I need for a Hubot MVP ( Minimum Viable Product ) … security.&lt;/p&gt;
</description>
        
          <description>&lt;p&gt;Researching global functions in Hubot lead me down two interesting paths: Classes and Middleware.  Middleware is pretty well documented on the &lt;a href=&quot;https://github.com/github/hubot/blob/master/docs/scripting.md&quot;&gt;Hubot Scripting page&lt;/a&gt;.  Classes on the other hand not so much.   So for learning about those … you guessed it … go to the code.  And with that I see that while Middleware has other uses, the Class is what I will use to create what I am calling a &lt;strong&gt;global function&lt;/strong&gt; (in javascript terminology this is a class with a method).   In another .coffee file in the scripts directory, create a Class and then a method in that class for the CC script. I decided to create a class with my company name as the class.  I will add other global functions under this same class so they are all grouped under my company name.  This methodology is likely to change as I learn more, but its working for now.  Here is what it looks like.&lt;/p&gt;

</description>
        
        <pubDate>Tue, 05 Apr 2016 00:00:00 -0700</pubDate>
        <link>http://twellspring.github.io/blog/hubot-global-functions/</link>
        <guid isPermaLink="true">http://twellspring.github.io/blog/hubot-global-functions/</guid>
        
        
      </item>
      
    
      
      <item>
        <title>Hubot Carbon Copy a Channel</title>
        <description>&lt;p&gt;My pondering on how to clearly log Hubot initiated saltstack changes to a Slack channel without having a bunch of &lt;strong&gt;help&lt;/strong&gt; and &lt;strong&gt;pug me&lt;/strong&gt; in the channel lead to developing a method to carbon copy (cc).  A cc would allow developers communicate with Hubot via Direct Message (DM) but to have the results of any action command ( i.e. commands that initiate changes to a server) in the desired Slack channel.  The documentation did not cover this, and googling lead me to some outdated solutions that no longer work.  But a little persistence and some looking at the code lead me to the solution of using robot.messageRoom, which is now documented on the &lt;a href=&quot;https://github.com/github/hubot/blob/master/docs/scripting.md&quot;&gt;Hubot scripting page &lt;/a&gt; ( or will be when &lt;a href=&quot;https://github.com/github/hubot/pull/1161&quot;&gt;the pull request&lt;/a&gt; is merged).&lt;/p&gt;

&lt;p&gt;So with robot.messageRoom I can add a CC after the msg.reply lines in the examples from my previous post.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ccChannel = &quot;some_channel&quot;
if jsonBody.result != &quot;failure&quot;
  msg.reply &quot;Successfully deployed #{appName} to #{serverName}&quot;
  robot.messageRoom ccChannel, &quot;Successfully deployed #{appName} to #{serverName}&quot;
else
  msg.reply &quot;Error deploying #{appName} to #{serverName}&quot;
  robot.messageRoom ccChannel msg.reply &quot;Error deploying #{appName} to #{serverName}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now when someone runs the deploy command via DM, in my channel that tracks staging changes I see a line&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hubot BOT [6:22 PM]
@someuser: Successfully deployed www to server xxx-xxx-xxx-1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;which shows the change made and who made it.   That’s just what we need, and I would have left it at this if I did not accidentally run a deploy command in the same channel as is defined for the cc.  And you guessed it … duplicate messages.   That’s not going to work.   And likewise I do not want to see duplicate messages when I am testing new commands locally via the Hubot command line.   So we now need to turn this into a function that has the logic necessary to suppress duplicates and can be called from multiple locations.  Creating a local function is my first try and I got that working without too much frustration and head-banging.  I decided to stick with “room” in my code as that is the generic term Hubot uses which in Slack’s case maps to a channel.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = (robot) -&amp;gt;

  ccRoom = &quot;some_channel&quot;

  cc = (msg, ccRoom, ccText) -&amp;gt;
    room = msg.envelope.room
    user = msg.envelope.user.name

    return if ccRoom == room
    return if user == &quot;Shell&quot;

    robot.messageRoom ccRoom &quot;#{ccText}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;A couple of CoffeeScript notes here.   The CoffeeScript &lt;strong&gt;return&lt;/strong&gt; call will exit the function without processing any more lines.  And the pattern “command if test” means those means those lines only get executed if the condition statement evaluates to true.  I like what I did above as the code is cleaner and more readable than a typical compound if-then-else&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ccRoom == room
  return
else
  if user == &quot;Shell&quot;
    return
  else
    robot.messageRoom ccRoom &quot;#{ccText}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;or using an &lt;strong&gt;or&lt;/strong&gt; in the if statement.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ccRoom == room or user == &quot;Shell&quot;
  return
else
  robot.messageRoom ccRoom &quot;#{ccText}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Notes done … back to the originally scheduled subject.   Using this new function requires replacing each robot.messageRoom line with a cc line.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cc(msg, ccRoom, &quot;Successfully deployed #{appName} to #{serverName}&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;While this works, I already have a couple of CoffeeScript files and this definition needs to be at the top of each one that needs to do a cc.  That is only one file for now, but I am sure there will be many more in the near future.  So using the local function is not a long term viable solution.  I need to be able to define this globally, and that ccRoom variable also needs to be defined globally.  One step forward, two steps back.&lt;/p&gt;
</description>
        
          <description>&lt;p&gt;My pondering on how to clearly log Hubot initiated saltstack changes to a Slack channel without having a bunch of &lt;strong&gt;help&lt;/strong&gt; and &lt;strong&gt;pug me&lt;/strong&gt; in the channel lead to developing a method to carbon copy (cc).  A cc would allow developers communicate with Hubot via Direct Message (DM) but to have the results of any action command ( i.e. commands that initiate changes to a server) in the desired Slack channel.  The documentation did not cover this, and googling lead me to some outdated solutions that no longer work.  But a little persistence and some looking at the code lead me to the solution of using robot.messageRoom, which is now documented on the &lt;a href=&quot;https://github.com/github/hubot/blob/master/docs/scripting.md&quot;&gt;Hubot scripting page &lt;/a&gt; ( or will be when &lt;a href=&quot;https://github.com/github/hubot/pull/1161&quot;&gt;the pull request&lt;/a&gt; is merged).&lt;/p&gt;

</description>
        
        <pubDate>Sun, 03 Apr 2016 00:00:00 -0700</pubDate>
        <link>http://twellspring.github.io/blog/hubot-carbon-copy-channel/</link>
        <guid isPermaLink="true">http://twellspring.github.io/blog/hubot-carbon-copy-channel/</guid>
        
        
      </item>
      
    
      
      <item>
        <title>Hubot Saltstack Integration</title>
        <description>&lt;p&gt;Before finding ChatOps our strategy was to create a salt-api in node.js that exposed just the needed parts of Saltstack via a RESTful API that returns JSON.  This would allow a developer to integrate Saltstack with our internal management tools with minimal understanding of salt. Much of the time the salt commands returned JSON that could be passed directly through the salt-api which made many salt-api commands easy to implement.  But there are cases where I found it beneficial to run multiple salt commands and aggregate data or to limit what part of the JSON data returned by salt gets returned through the salt-api.&lt;/p&gt;

&lt;p&gt;When ChatOps “arrived”, the decisions for the above methodology still made sense.  In the future the Saltstack and Hubot development might not always be done by the same person so, like above, this allows the Hubot developer to not have to know Saltstack intimately. And our internal salt-api provides a control layer to strictly limit what ChatOps can do.  This is important as at this point I am not confident enough in Hubot’s security design &amp;amp; implementation to trust it with full access to all salt commands and by extension to all facets of production servers. ( But as it is open source, I will be looking into this in the future. )&lt;/p&gt;

&lt;p&gt;And so to integrate Hubot with my salt-api was a standard CoffeeScript http call.  The pattern for my Hubotized salt commands follow this pattern&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;robot.respond&lt;/li&gt;
  &lt;li&gt;http request to salt&lt;/li&gt;
  &lt;li&gt;error checking&lt;/li&gt;
  &lt;li&gt;response to user&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is some boilerplate code for getting information about a server from salt-api
( if needed, scroll left/right in text box to see full lines)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;robot.respond /Get information about server *([\w-_]+)/i, (msg) -&amp;gt;
  serverName = msg.match[1]
  httpURL = &quot;#{saltUrl}/server/#{serverName}&quot;
  msg.http(httpURL)
    .headers(&#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: saltAuth)
    .get() (err, res, body) -&amp;gt;
      try
        jsonBody = JSON.parse(body)
        if jsonBody.result != &quot;failure&quot;
          textBody = JSON.stringify(jsonBody, null, 2)
          msg.reply &quot;Here is information about `#{serverName}`\n```#{textBody}```&quot;
        else
          msg.reply &quot;I could not find any information.  Are you sure `#{serverName}` is a real server?&quot;
      catch error
        msg.reply &quot;There was an general error:\n#{err} getting data aboug #{serverName}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Though this code is specific to the internal salt-api, the same methodology works for accessing Saltstack API.  And doing POST/PUT requests just requires changing the method and passing the appropriate body.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;robot.respond /deploy ([\w-]+) to ([\w-]+) version ([\w-_/\.]+)?([\w-_]+)?/i, (msg) -&amp;gt;
  appName     = msg.match[1]
  serverName  = msg.match[2]
  appVersion = msg.match[3]

  postData = JSON.stringify({
    version: appVersion
  })

  httpURL = &quot;#{saltUrl}/server/#{serverName}&quot;/app/#{appName}&quot;

  msg.http(httpURL)
    .headers(&#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: saltAuth)
    .put(postData) (err, res, body) -&amp;gt;
      try
        jsonBody = JSON.parse(body)
        if jsonBody.result != &quot;failure&quot;
          msg.reply &quot;Successfully deployed #{appName} to #{serverName}&quot;
        else
          msg.reply &quot;Error deploying #{appName} to #{serverName}&quot;
      catch error
        msg.reply &quot;There was an general error:\n#{err} deploying #{appName} to #{serverName}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;My nascent Hubot skills are sufficient now to create a MVP ( minimum viable product ) for my company ChatOps. &lt;br /&gt;
For my initial ChatOps deploy the MVP is&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;list types of servers&lt;/li&gt;
  &lt;li&gt;list all servers of a given type&lt;/li&gt;
  &lt;li&gt;Get information about a particular server ( ip, version of app installed, …. )&lt;/li&gt;
  &lt;li&gt;Deploy an app branch/tag/hash to a server&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For the longer requests like deploy I decided to add in a msg.send line before the msg.http.  This gives immediate feedback to the user so they know that Hubot is on the job.  Something like:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;msg.send &quot;Deploying #{version} to #{server}. \nIf this takes a few minutes, it is probably due to a slow `npm install`.&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And with the above in place, I introduced ChatOps to my developers in a new slack room dedicated to hubot.   Many commented on how cool this was, and they played with the commands.  But it took a few days until people started really using the above server commands.   It quickly became apparent that having all Hubot commands in that one room made a big mess.  The goal of this room was to have a log of changes being made via Hubot, but with all the &lt;code class=&quot;highlighter-rouge&quot;&gt;pug me&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ship it&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;help&lt;/code&gt; commands it was quite unreadable.  So I went looking for how our dedicated room could be brought back to the goal.&lt;/p&gt;
</description>
        
          <description>&lt;p&gt;Before finding ChatOps our strategy was to create a salt-api in node.js that exposed just the needed parts of Saltstack via a RESTful API that returns JSON.  This would allow a developer to integrate Saltstack with our internal management tools with minimal understanding of salt. Much of the time the salt commands returned JSON that could be passed directly through the salt-api which made many salt-api commands easy to implement.  But there are cases where I found it beneficial to run multiple salt commands and aggregate data or to limit what part of the JSON data returned by salt gets returned through the salt-api.&lt;/p&gt;

</description>
        
        <pubDate>Fri, 01 Apr 2016 00:00:00 -0700</pubDate>
        <link>http://twellspring.github.io/blog/hubot-salt-integration/</link>
        <guid isPermaLink="true">http://twellspring.github.io/blog/hubot-salt-integration/</guid>
        
        
      </item>
      
    
      
      <item>
        <title>Chatops and Hubot the basics</title>
        <description>&lt;p&gt;Hubot was really not hard get started with.   I started with it on my MacOS laptop.   I already had these dependencies installed&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;node.js 5.x&lt;/li&gt;
  &lt;li&gt;npm&lt;/li&gt;
  &lt;li&gt;git&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So what was left from the &lt;a href=&quot;https://hubot.github.com/docs/&quot;&gt;hubot installation instructions &lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Install hubot libraries/components: &lt;code class=&quot;highlighter-rouge&quot;&gt;npm install -g yo generator-hubot&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Generate an instance of hubot: &lt;code class=&quot;highlighter-rouge&quot;&gt;mkdir hubot; cd hubot; yo hubot&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Start hubot: &lt;code class=&quot;highlighter-rouge&quot;&gt;bin/Hubot&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Stop hubot: &lt;code class=&quot;highlighter-rouge&quot;&gt;control-c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And I had a hubot instance running.   I could give it commands on the command line and get responses.  help showed me all the things that come by default.  After trying all the default commands out, I disabled several items that I did not want ( like google translate.)  To remove one of the pre-bundled items you need to&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Remove the item from package.json&lt;/li&gt;
  &lt;li&gt;Delete the node_modules/xxxxx directory of the same name&lt;/li&gt;
  &lt;li&gt;Remove the entry from &lt;code class=&quot;highlighter-rouge&quot;&gt;external-scripts.json&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;start/restart hubot&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There are many additional plugins available at &lt;a href=&quot;https://github.com/hubot-scripts&quot;&gt;hubot scripts&lt;/a&gt;.  Two that I installed are&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;hubot-auth - user roles to be used for command authorization&lt;/li&gt;
  &lt;li&gt;hubot-diagnostics - some tools to help with basic troubleshooting&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To install a plugin&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;npm install  --save xxxxxx&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;edit &lt;code class=&quot;highlighter-rouge&quot;&gt;external-scripts.json&lt;/code&gt; and add the plugin&lt;/li&gt;
  &lt;li&gt;start/restart hubot&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now to get slack working.  I had my slack admin create a hubot integration and give me the token.   Then it is just&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Install the plugin: &lt;code class=&quot;highlighter-rouge&quot;&gt;npm install --save hubot-slack&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;To my environment add the slack token: &lt;code class=&quot;highlighter-rouge&quot;&gt;export HUBOT_SLACK_TOKEN=xoxb-XXXX-XXXXXX-XXXXXX-XXXXXX&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Start hubot with slack enabled:  &lt;code class=&quot;highlighter-rouge&quot;&gt;bin/hubot --adapter slack&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And all of a sudden hubot showed up in my slack as a bot.  Invite hubot to a room and then he will listen there.&lt;/p&gt;

&lt;p&gt;Something that I found missing from hubot was the ability to use .env files like all my other node apps ( using dotenv or similar ).  Hubot can use a .env file but it requires **export in front of each line.   I am using a modified node_modules/.bin/hubot to allow me to use “normally” formatted .env files.  That edit has been &lt;a href=&quot;https://github.com/github/hubot/issues/1153&quot;&gt;submitted to github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;With it, my .env now has three variables&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HUBOT_SLACK_TOKEN=xoxb-XXXXXXXXXXX-XXXXXXXXXXXXXXXXXXXXXXXX
HUBOT_AUTH_ADMIN=1
HUBOT_SALT_AUTH=XXXXXXXXXXXXXXXXXX
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The First variable I have already talked about.  The remaining two will be covered in the next two posts about Saltstack and Security.&lt;/p&gt;
</description>
        
          <description>&lt;p&gt;Hubot was really not hard get started with.   I started with it on my MacOS laptop.   I already had these dependencies installed&lt;/p&gt;

</description>
        
        <pubDate>Sun, 27 Mar 2016 00:00:00 -0700</pubDate>
        <link>http://twellspring.github.io/blog/chatops-and-hubot-the-basics/</link>
        <guid isPermaLink="true">http://twellspring.github.io/blog/chatops-and-hubot-the-basics/</guid>
        
        
      </item>
      
    
      
      <item>
        <title>Chatops Integration with Automation Tools</title>
        <description>&lt;p&gt;Discovering ChatOps and a couple of hours of googling/reading lead me down the garden path of how to Integrate. I am using &lt;a href=&quot;http://saltstack.com/&quot;&gt;SaltStack&lt;/a&gt; for IT Automation ( sorry no Puppet/Chef here). SaltStack has served that role admirably. And now I want to move forward with ChatOps. To do that of course ChatOps needs to talk to SaltStack, which means a bot. And the bot that seemed the best to me was &lt;a href=&quot;https://hubot.github.com/&quot;&gt;Hubot&lt;/a&gt; from those fine people at github that started this whole ChatOps thing.&lt;/p&gt;

&lt;p&gt;Unfortunately, when I looked at how to get Hubot and Slack talking I let scope creep come in. I decided that a tool that already groked ChatOps and spoke both hubot-ese and slack-ese would be a good idea. This was a best intention for I wanted to make sure I was not contributing to integration hell with dozens of different integrations to our chat software Slack. There are already several different sources sending data into Slack. And ChatOps will be another one. And then there is SalesForce integration to slack. And I am sure many more to come. What If I could put a tool in place that would be the gateway between Slack and all of these tools. It would be a layer of abstraction that could be good to have.&lt;/p&gt;

&lt;p&gt;And so I ended up trying two options: &lt;a href=&quot;https://stackstorm.com/&quot;&gt;StackStorm&lt;/a&gt; and &lt;a href=&quot;http://rundeck.org/&quot;&gt;Rundeck&lt;/a&gt;. I liked both of these tools for different reasons, but I thought that the more dynamic event driven jobs scheduling model of StackStorm fit better. After all, ChatOps is also event driven so using StackStorm with its integrations to the major chat platforms seemed like a good solution. The StackStorm all-in-one installer got me up and running quickly, but with a few problems with the integration to SaltSack. Thanks to the very responsive ( and Slack based ) &lt;strong&gt;community&lt;/strong&gt; group at StackStorm I was able to get it working.&lt;/p&gt;

&lt;p&gt;And by working I mean I now have every salt command available inside of my Slack, including the ability to run arbitrary commands against any server … test, staging, PROD. Nope, not going to leave that in place. ChatOps needs some limits, so I set forth to figure out how to limit it to just what I wanted to expose. But hours later I was not really making progress on those limits. The integration layer between StackStorm and the Hubot bot that actually connected to Slack did not really seem to have the flexibility to do what I wanted. Or if it did it was going to take a lot of work to figure out and there was not a lot of information out there to help me.&lt;/p&gt;

&lt;p&gt;Time to regroup and re-assess. The gateway ( StackStorm ) was making the job of integrating my SaltStack and Slack harder, and I was not convinced that my goal of using it as a single point of integration was really going to work. And so I jettisoned the scope creep and went back to a simple integration between SaltStack and Hubot.&lt;/p&gt;

&lt;p&gt;Note: I really did like what StackStorm was trying to do and I am thinking that once I have some better experience with ChatOps under my belt I will be revisiting their solution as a dynamic job scheduler that might or might not integrate with the stand-alone hubot I am setting up now.&lt;/p&gt;
</description>
        
          <description>&lt;p&gt;Discovering ChatOps and a couple of hours of googling/reading lead me down the garden path of how to Integrate. I am using &lt;a href=&quot;http://saltstack.com/&quot;&gt;SaltStack&lt;/a&gt; for IT Automation ( sorry no Puppet/Chef here). SaltStack has served that role admirably. And now I want to move forward with ChatOps. To do that of course ChatOps needs to talk to SaltStack, which means a bot. And the bot that seemed the best to me was &lt;a href=&quot;https://hubot.github.com/&quot;&gt;Hubot&lt;/a&gt; from those fine people at github that started this whole ChatOps thing.&lt;/p&gt;

</description>
        
        <pubDate>Wed, 23 Mar 2016 00:00:00 -0700</pubDate>
        <link>http://twellspring.github.io/blog/chatops-integration-with-automation-tools/</link>
        <guid isPermaLink="true">http://twellspring.github.io/blog/chatops-integration-with-automation-tools/</guid>
        
        
      </item>
      
    
      
      <item>
        <title>ChatOps FOMO</title>
        <description>&lt;p&gt;A month ago I “discovered” the term &lt;strong&gt;ChatOps&lt;/strong&gt; and was a little surprised it has been around for over 3 years. Guess I have missed out, but not any more. Time to get me some ChatOps. But first, thanks to the &lt;a href=&quot;https://speakerdeck.com/jnewland/chatops&quot;&gt;githubbers&lt;/a&gt; who came up with this idea.&lt;/p&gt;

&lt;p&gt;I liked &lt;a href=&quot;https://www.pagerduty.com/blog/what-is-chatops/&quot;&gt;this definition of ChatOps&lt;/a&gt;. It starts with a culture where chat is the method of development collaboration and adds in tools so that actions are part of the conversation. If you don’t already have the culture adding tools will not really help. But if you do have the culture then adding in the tooling will just make collaboration that much better.&lt;/p&gt;

&lt;p&gt;It only took a few minutes of research for me to understand how valuable this could be. There was definitely coincidence involved in that quick understanding. As the DevOps engineer for a &amp;gt; 20 developer shop, I was used to the requests “can you change staging server xxx-xxxxx-xxx-1 to track branch feature/yyyyyyyyy” happening a few times per week. But in the 2 days before I discovered “ChatOps” it started happening several times per day. The “&lt;a href=&quot;http://www.thegeekstuff.com/2011/07/lazy-sysadmin/&quot;&gt;lazy sysadmin&lt;/a&gt;” in me had of course automated the process so it only took a minute to satisfy these requests. But the increase in frequency was causing chafing at having to make this change at all. Now comes ChatOps as a solution to this chafing.&lt;/p&gt;

&lt;p&gt;But how to implement ChatOps. My next hour or two of research gave me many possibilities, and lead me down a path of frustration and eventually starting over and going with the simple solution.&lt;/p&gt;
</description>
        
          <description>&lt;p&gt;A month ago I “discovered” the term &lt;strong&gt;ChatOps&lt;/strong&gt; and was a little surprised it has been around for over 3 years. Guess I have missed out, but not any more. Time to get me some ChatOps. But first, thanks to the &lt;a href=&quot;https://speakerdeck.com/jnewland/chatops&quot;&gt;githubbers&lt;/a&gt; who came up with this idea.&lt;/p&gt;

</description>
        
        <pubDate>Sun, 20 Mar 2016 00:00:00 -0700</pubDate>
        <link>http://twellspring.github.io/blog/chatops-fomo/</link>
        <guid isPermaLink="true">http://twellspring.github.io/blog/chatops-fomo/</guid>
        
        
      </item>
      
    
  </channel>
</rss>
