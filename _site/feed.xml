<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Todd Wells</title>
    <description>Techie type with his feet in the Sierra Nevada Mountains and his head in the cloud</description>
    <link>http://twellspring.github.io/</link>
    <atom:link href="http://twellspring.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 03 Apr 2016 16:04:22 -0700</pubDate>
    <lastBuildDate>Sun, 03 Apr 2016 16:04:22 -0700</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      
      <item>
        <title>Hubot Carbon Copy a Channel</title>
        <description>&lt;p&gt;My pondering on how to clearly log Hubot initiated saltstack changes to a Slack channel without having a bunch of &lt;strong&gt;help&lt;/strong&gt; and &lt;strong&gt;pug me&lt;/strong&gt; in the channel lead to developing a method to carbon copy (cc).  A cc would allow developers communicate with Hubot via Direct Message (DM) but to have the results of any action command ( i.e. commands that initiate changes to a server) in the desired Slack channel.  The documentation did not cover this, and googling lead me to some outdated solutions that no longer work.  But a little persistence and some looking at the code lead me to the solution of using robot.messageRoom, which is now documented on the &lt;a href=&quot;https://github.com/github/hubot/blob/master/docs/scripting.md&quot;&gt;Hubot scripting page &lt;/a&gt; ( or will be when &lt;a href=&quot;https://github.com/github/hubot/pull/1161&quot;&gt;the pull request&lt;/a&gt; is merged).&lt;/p&gt;

&lt;p&gt;So with robot.messageRoom I can add a CC after the msg.reply lines in the examples from my previous post.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ccChannel = &quot;some_channel&quot;
if jsonBody.result != &quot;failure&quot;
  msg.reply &quot;Successfully deployed #{appName} to #{serverName}&quot;
  robot.messageRoom ccChannel, &quot;Successfully deployed #{appName} to #{serverName}&quot;
else
  msg.reply &quot;Error deploying #{appName} to #{serverName}&quot;
  robot.messageRoom ccChannel msg.reply &quot;Error deploying #{appName} to #{serverName}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now when someone runs the deploy command via DM, in my channel that tracks staging changes I see a line&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hubot BOT [6:22 PM]
@someuser: Successfully deployed www to server xxx-xxx-xxx-1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;which shows the change made and who made it.   That’s just what we need, and I would have left it at this if I did not accidentally run a deploy command in the same channel as is defined for the cc.  And you guessed it … duplicate messages.   That’s not going to work.   And likewise I do not want to see duplicate messages when I am testing new commands locally via the Hubot command line.   So we now need to turn this into a function that has the logic necessary to suppress duplicates and can be called from multiple locations.  Creating a local function is my first try and I got that working without too much frustration and head-banging.  I decided to stick with “room” in my code as that is the generic term Hubot uses which in Slack’s case maps to a channel.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = (robot) -&amp;gt;

  ccRoom = &quot;some_channel&quot;

  cc = (msg, ccRoom, ccText) -&amp;gt;
    room = msg.envelope.room
    user = msg.envelope.user.name

    return if ccRoom == room
    return if user == &quot;Shell&quot;

    robot.messageRoom ccRoom &quot;#{ccText}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;A couple of CoffeeScript notes here.   The CoffeeScript &lt;strong&gt;return&lt;/strong&gt; call will exit the function without processing any more lines.  And the pattern “command if test” means those means those lines only get executed if the condition statement evaluates to true.  I like what I did above as the code is cleaner and more readable than a typical compound if-then-else&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ccRoom == room
  return
else
  if user == &quot;Shell&quot;
    return
  else
    robot.messageRoom ccRoom &quot;#{ccText}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;or using an &lt;strong&gt;or&lt;/strong&gt; in the if statement.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ccRoom == room or user == &quot;Shell&quot;
  return
else
  robot.messageRoom ccRoom &quot;#{ccText}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Notes done … back to the originally scheduled subject.   Using this new function requires replacing each robot.messageRoom line with a cc line.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cc(msg, ccRoom, &quot;Successfully deployed #{appName} to #{serverName}&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;While this works, I already have a couple of CoffeeScript files and this definition needs to be at the top of each one that needs to do a cc.  That is only one file for now, but I am sure there will be many more in the near future.  So using the local function is not a long term viable solution.  I need to be able to define this globally, and that ccRoom variable also needs to be defined globally.  One step forward, two steps back.&lt;/p&gt;
</description>
        
          <description>&lt;p&gt;My pondering on how to clearly log Hubot initiated saltstack changes to a Slack channel without having a bunch of &lt;strong&gt;help&lt;/strong&gt; and &lt;strong&gt;pug me&lt;/strong&gt; in the channel lead to developing a method to carbon copy (cc).  A cc would allow developers communicate with Hubot via Direct Message (DM) but to have the results of any action command ( i.e. commands that initiate changes to a server) in the desired Slack channel.  The documentation did not cover this, and googling lead me to some outdated solutions that no longer work.  But a little persistence and some looking at the code lead me to the solution of using robot.messageRoom, which is now documented on the &lt;a href=&quot;https://github.com/github/hubot/blob/master/docs/scripting.md&quot;&gt;Hubot scripting page &lt;/a&gt; ( or will be when &lt;a href=&quot;https://github.com/github/hubot/pull/1161&quot;&gt;the pull request&lt;/a&gt; is merged).&lt;/p&gt;

</description>
        
        <pubDate>Sun, 03 Apr 2016 00:00:00 -0700</pubDate>
        <link>http://twellspring.github.io/blog/hubot-carbon-copy-channel/</link>
        <guid isPermaLink="true">http://twellspring.github.io/blog/hubot-carbon-copy-channel/</guid>
        
        
      </item>
      
    
      
      <item>
        <title>Hubot Saltstack Integration</title>
        <description>&lt;p&gt;Before finding ChatOps our strategy was to create a salt-api in node.js that exposed just the needed parts of Saltstack via a RESTful API that returns JSON.  This would allow a developer to integrate Saltstack with our internal management tools with minimal understanding of salt. Much of the time the salt commands returned JSON that could be passed directly through the salt-api which made many salt-api commands easy to implement.  But there are cases where I found it beneficial to run multiple salt commands and aggregate data or to limit what part of the JSON data returned by salt gets returned through the salt-api.&lt;/p&gt;

&lt;p&gt;When ChatOps “arrived”, the decisions for the above methodology still made sense.  In the future the Saltstack and Hubot development might not always be done by the same person so, like above, this allows the Hubot developer to not have to know Saltstack intimately. And our internal salt-api provides a control layer to strictly limit what ChatOps can do.  This is important as at this point I am not confident enough in Hubot’s security design &amp;amp; implementation to trust it with full access to all salt commands and by extension to all facets of production servers. ( But as it is open source, I will be looking into this in the future. )&lt;/p&gt;

&lt;p&gt;And so to integrate Hubot with my salt-api was a standard CoffeeScript http call.  The pattern for my Hubotized salt commands follow this pattern&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;robot.respond&lt;/li&gt;
  &lt;li&gt;http request to salt&lt;/li&gt;
  &lt;li&gt;error checking&lt;/li&gt;
  &lt;li&gt;response to user&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is some boilerplate code for getting information about a server from salt-api
( if needed, scroll left/right in text box to see full lines)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;robot.respond /Get information about server *([\w-_]+)/i, (msg) -&amp;gt;
  serverName = msg.match[1]
  httpURL = &quot;#{saltUrl}/server/#{serverName}&quot;
  msg.http(httpURL)
    .headers(&#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: saltAuth)
    .get() (err, res, body) -&amp;gt;
      try
        jsonBody = JSON.parse(body)
        if jsonBody.result != &quot;failure&quot;
          textBody = JSON.stringify(jsonBody, null, 2)
          msg.reply &quot;Here is information about `#{serverName}`\n```#{textBody}```&quot;
        else
          msg.reply &quot;I could not find any information.  Are you sure `#{serverName}` is a real server?&quot;
      catch error
        msg.reply &quot;There was an general error:\n#{err} getting data aboug #{serverName}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Though this code is specific to the internal salt-api, the same methodology works for accessing Saltstack API.  And doing POST/PUT requests just requires changing the method and passing the appropriate body.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;robot.respond /deploy ([\w-]+) to ([\w-]+) version ([\w-_/\.]+)?([\w-_]+)?/i, (msg) -&amp;gt;
  appName     = msg.match[1]
  serverName  = msg.match[2]
  appVersion = msg.match[3]

  postData = JSON.stringify({
    version: appVersion
  })

  httpURL = &quot;#{saltUrl}/server/#{serverName}&quot;/app/#{appName}&quot;

  msg.http(httpURL)
    .headers(&#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: saltAuth)
    .put(postData) (err, res, body) -&amp;gt;
      try
        jsonBody = JSON.parse(body)
        if jsonBody.result != &quot;failure&quot;
          msg.reply &quot;Successfully deployed #{appName} to #{serverName}&quot;
        else
          msg.reply &quot;Error deploying #{appName} to #{serverName}&quot;
      catch error
        msg.reply &quot;There was an general error:\n#{err} deploying #{appName} to #{serverName}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;My nascent Hubot skills are sufficient now to create a MVP ( minimum viable product ) for my company ChatOps. &lt;br /&gt;
For my initial ChatOps deploy the MVP is&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;list types of servers&lt;/li&gt;
  &lt;li&gt;list all servers of a given type&lt;/li&gt;
  &lt;li&gt;Get information about a particular server ( ip, version of app installed, …. )&lt;/li&gt;
  &lt;li&gt;Deploy an app branch/tag/hash to a server&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For the longer requests like deploy I decided to add in a msg.send line before the msg.http.  This gives immediate feedback to the user so they know that Hubot is on the job.  Something like:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;msg.send &quot;Deploying #{version} to #{server}. \nIf this takes a few minutes, it is probably due to a slow `npm install`.&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And with the above in place, I introduced ChatOps to my developers in a new slack room dedicated to hubot.   Many commented on how cool this was, and they played with the commands.  But it took a few days until people started really using the above server commands.   It quickly became apparent that having all Hubot commands in that one room made a big mess.  The goal of this room was to have a log of changes being made via Hubot, but with all the &lt;code class=&quot;highlighter-rouge&quot;&gt;pug me&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ship it&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;help&lt;/code&gt; commands it was quite unreadable.  So I went looking for how our dedicated room could be brought back to the goal.&lt;/p&gt;
</description>
        
          <description>&lt;p&gt;Before finding ChatOps our strategy was to create a salt-api in node.js that exposed just the needed parts of Saltstack via a RESTful API that returns JSON.  This would allow a developer to integrate Saltstack with our internal management tools with minimal understanding of salt. Much of the time the salt commands returned JSON that could be passed directly through the salt-api which made many salt-api commands easy to implement.  But there are cases where I found it beneficial to run multiple salt commands and aggregate data or to limit what part of the JSON data returned by salt gets returned through the salt-api.&lt;/p&gt;

</description>
        
        <pubDate>Fri, 01 Apr 2016 00:00:00 -0700</pubDate>
        <link>http://twellspring.github.io/blog/hubot-salt-integration/</link>
        <guid isPermaLink="true">http://twellspring.github.io/blog/hubot-salt-integration/</guid>
        
        
      </item>
      
    
      
      <item>
        <title>Chatops and Hubot the basics</title>
        <description>&lt;p&gt;Hubot was really not hard get started with.   I started with it on my MacOS laptop.   I already had these dependencies installed&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;node.js 5.x&lt;/li&gt;
  &lt;li&gt;npm&lt;/li&gt;
  &lt;li&gt;git&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So what was left from the &lt;a href=&quot;https://hubot.github.com/docs/&quot;&gt;hubot installation instructions &lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Install hubot libraries/components: &lt;code class=&quot;highlighter-rouge&quot;&gt;npm install -g yo generator-hubot&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Generate an instance of hubot: &lt;code class=&quot;highlighter-rouge&quot;&gt;mkdir hubot; cd hubot; yo hubot&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Start hubot: &lt;code class=&quot;highlighter-rouge&quot;&gt;bin/Hubot&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Stop hubot: &lt;code class=&quot;highlighter-rouge&quot;&gt;control-c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And I had a hubot instance running.   I could give it commands on the command line and get responses.  help showed me all the things that come by default.  After trying all the default commands out, I disabled several items that I did not want ( like google translate.)  To remove one of the pre-bundled items you need to&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Remove the item from package.json&lt;/li&gt;
  &lt;li&gt;Delete the node_modules/xxxxx directory of the same name&lt;/li&gt;
  &lt;li&gt;Remove the entry from &lt;code class=&quot;highlighter-rouge&quot;&gt;external-scripts.json&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;start/restart hubot&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There are many additional plugins available at &lt;a href=&quot;https://github.com/hubot-scripts&quot;&gt;hubot scripts&lt;/a&gt;.  Two that I installed are&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;hubot-auth - user roles to be used for command authorization&lt;/li&gt;
  &lt;li&gt;hubot-diagnostics - some tools to help with basic troubleshooting&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To install a plugin&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;npm install  --save xxxxxx&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;edit &lt;code class=&quot;highlighter-rouge&quot;&gt;external-scripts.json&lt;/code&gt; and add the plugin&lt;/li&gt;
  &lt;li&gt;start/restart hubot&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now to get slack working.  I had my slack admin create a hubot integration and give me the token.   Then it is just&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Install the plugin: &lt;code class=&quot;highlighter-rouge&quot;&gt;npm install --save hubot-slack&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;To my environment add the slack token: &lt;code class=&quot;highlighter-rouge&quot;&gt;export HUBOT_SLACK_TOKEN=xoxb-XXXX-XXXXXX-XXXXXX-XXXXXX&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Start hubot with slack enabled:  &lt;code class=&quot;highlighter-rouge&quot;&gt;bin/hubot --adapter slack&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And all of a sudden hubot showed up in my slack as a bot.  Invite hubot to a room and then he will listen there.&lt;/p&gt;

&lt;p&gt;Something that I found missing from hubot was the ability to use .env files like all my other node apps ( using dotenv or similar ).  Hubot can use a .env file but it requires &lt;code class=&quot;highlighter-rouge&quot;&gt;export&lt;/code&gt; in front of each line.   I am using a modified node_modules/.bin/hubot to allow me to use “normally” formatted .env files.  That edit has been &lt;a href=&quot;https://github.com/github/hubot/issues/1153&quot;&gt;submitted to github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;With it, my .env now has three variables&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HUBOT_SLACK_TOKEN=xoxb-XXXXXXXXXXX-XXXXXXXXXXXXXXXXXXXXXXXX
HUBOT_AUTH_ADMIN=1
HUBOT_SALT_AUTH=XXXXXXXXXXXXXXXXXX
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The First variable I have already talked about.  The remaining two will be covered in the next two posts about Saltstack and Security.&lt;/p&gt;
</description>
        
          <description>&lt;p&gt;Hubot was really not hard get started with.   I started with it on my MacOS laptop.   I already had these dependencies installed&lt;/p&gt;

</description>
        
        <pubDate>Sun, 27 Mar 2016 00:00:00 -0700</pubDate>
        <link>http://twellspring.github.io/blog/chatops-and-hubot-the-basics/</link>
        <guid isPermaLink="true">http://twellspring.github.io/blog/chatops-and-hubot-the-basics/</guid>
        
        
      </item>
      
    
      
      <item>
        <title>Chatops Integration with Automation Tools</title>
        <description>&lt;p&gt;Discovering ChatOps and a couple of hours of googling/reading lead me down the garden path of how to Integrate. I am using &lt;a href=&quot;http://saltstack.com/&quot;&gt;SaltStack&lt;/a&gt; for IT Automation ( sorry no Puppet/Chef here). SaltStack has served that role admirably. And now I want to move forward with ChatOps. To do that of course ChatOps needs to talk to SaltStack, which means a bot. And the bot that seemed the best to me was &lt;a href=&quot;https://hubot.github.com/&quot;&gt;Hubot&lt;/a&gt; from those fine people at github that started this whole ChatOps thing.&lt;/p&gt;

&lt;p&gt;Unfortunately, when I looked at how to get Hubot and Slack talking I let scope creep come in. I decided that a tool that already groked ChatOps and spoke both hubot-ese and slack-ese would be a good idea. This was a best intention for I wanted to make sure I was not contributing to integration hell with dozens of different integrations to our chat software Slack. There are already several different sources sending data into Slack. And ChatOps will be another one. And then there is SalesForce integration to slack. And I am sure many more to come. What If I could put a tool in place that would be the gateway between Slack and all of these tools. It would be a layer of abstraction that could be good to have.&lt;/p&gt;

&lt;p&gt;And so I ended up trying two options: &lt;a href=&quot;https://stackstorm.com/&quot;&gt;StackStorm&lt;/a&gt; and &lt;a href=&quot;http://rundeck.org/&quot;&gt;Rundeck&lt;/a&gt;. I liked both of these tools for different reasons, but I thought that the more dynamic event driven jobs scheduling model of StackStorm fit better. After all, ChatOps is also event driven so using StackStorm with its integrations to the major chat platforms seemed like a good solution. The StackStorm all-in-one installer got me up and running quickly, but with a few problems with the integration to SaltSack. Thanks to the very responsive ( and Slack based ) &lt;strong&gt;community&lt;/strong&gt; group at StackStorm I was able to get it working.&lt;/p&gt;

&lt;p&gt;And by working I mean I now have every salt command available inside of my Slack, including the ability to run arbitrary commands against any server … test, staging, PROD. Nope, not going to leave that in place. ChatOps needs some limits, so I set forth to figure out how to limit it to just what I wanted to expose. But hours later I was not really making progress on those limits. The integration layer between StackStorm and the Hubot bot that actually connected to Slack did not really seem to have the flexibility to do what I wanted. Or if it did it was going to take a lot of work to figure out and there was not a lot of information out there to help me.&lt;/p&gt;

&lt;p&gt;Time to regroup and re-assess. The gateway ( StackStorm ) was making the job of integrating my SaltStack and Slack harder, and I was not convinced that my goal of using it as a single point of integration was really going to work. And so I jettisoned the scope creep and went back to a simple integration between SaltStack and Hubot.&lt;/p&gt;

&lt;p&gt;Note: I really did like what StackStorm was trying to do and I am thinking that once I have some better experience with ChatOps under my belt I will be revisiting their solution as a dynamic job scheduler that might or might not integrate with the stand-alone hubot I am setting up now.&lt;/p&gt;
</description>
        
          <description>&lt;p&gt;Discovering ChatOps and a couple of hours of googling/reading lead me down the garden path of how to Integrate. I am using &lt;a href=&quot;http://saltstack.com/&quot;&gt;SaltStack&lt;/a&gt; for IT Automation ( sorry no Puppet/Chef here). SaltStack has served that role admirably. And now I want to move forward with ChatOps. To do that of course ChatOps needs to talk to SaltStack, which means a bot. And the bot that seemed the best to me was &lt;a href=&quot;https://hubot.github.com/&quot;&gt;Hubot&lt;/a&gt; from those fine people at github that started this whole ChatOps thing.&lt;/p&gt;

</description>
        
        <pubDate>Wed, 23 Mar 2016 00:00:00 -0700</pubDate>
        <link>http://twellspring.github.io/blog/chatops-integration-with-automation-tools/</link>
        <guid isPermaLink="true">http://twellspring.github.io/blog/chatops-integration-with-automation-tools/</guid>
        
        
      </item>
      
    
      
      <item>
        <title>ChatOps FOMO</title>
        <description>&lt;p&gt;A month ago I “discovered” the term &lt;strong&gt;ChatOps&lt;/strong&gt; and was a little surprised it has been around for over 3 years. Guess I have missed out, but not any more. Time to get me some ChatOps. But first, thanks to the &lt;a href=&quot;https://speakerdeck.com/jnewland/chatops&quot;&gt;githubbers&lt;/a&gt; who came up with this idea.&lt;/p&gt;

&lt;p&gt;I liked &lt;a href=&quot;https://www.pagerduty.com/blog/what-is-chatops/&quot;&gt;this definition of ChatOps&lt;/a&gt;. It starts with a culture where chat is the method of development collaboration and adds in tools so that actions are part of the conversation. If you don’t already have the culture adding tools will not really help. But if you do have the culture then adding in the tooling will just make collaboration that much better.&lt;/p&gt;

&lt;p&gt;It only took a few minutes of research for me to understand how valuable this could be. There was definitely coincidence involved in that quick understanding. As the DevOps engineer for a &amp;gt; 20 developer shop, I was used to the requests “can you change staging server xxx-xxxxx-xxx-1 to track branch feature/yyyyyyyyy” happening a few times per week. But in the 2 days before I discovered “ChatOps” it started happening several times per day. The “&lt;a href=&quot;http://www.thegeekstuff.com/2011/07/lazy-sysadmin/&quot;&gt;lazy sysadmin&lt;/a&gt;” in me had of course automated the process so it only took a minute to satisfy these requests. But the increase in frequency was causing chafing at having to make this change at all. Now comes ChatOps as a solution to this chafing.&lt;/p&gt;

&lt;p&gt;But how to implement ChatOps. My next hour or two of research gave me many possibilities, and lead me down a path of frustration and eventually starting over and going with the simple solution.&lt;/p&gt;
</description>
        
          <description>&lt;p&gt;A month ago I “discovered” the term &lt;strong&gt;ChatOps&lt;/strong&gt; and was a little surprised it has been around for over 3 years. Guess I have missed out, but not any more. Time to get me some ChatOps. But first, thanks to the &lt;a href=&quot;https://speakerdeck.com/jnewland/chatops&quot;&gt;githubbers&lt;/a&gt; who came up with this idea.&lt;/p&gt;

</description>
        
        <pubDate>Sun, 20 Mar 2016 00:00:00 -0700</pubDate>
        <link>http://twellspring.github.io/blog/chatops-fomo/</link>
        <guid isPermaLink="true">http://twellspring.github.io/blog/chatops-fomo/</guid>
        
        
      </item>
      
    
  </channel>
</rss>
